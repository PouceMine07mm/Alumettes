---


################################################################################


- name: "Get Ansible to do facts gathering only if it has not already done so"
  import_playbook: gather_facts.yaml
  tags:
    - gather


# - hosts:
#     - all
#   tasks:
#     - name: 'preparation pour instalation de certbot' # voir erreur : E: The repository 'http://ppa.launchpad.net/certbot/certbot/ubuntu eoan Release' does not have a Release file
#       command: "{{ item.commande }}"
#       loop:
#         - { commande: "apt-get update --allow-releaseinfo-change", commentaire: "" }
#         - { commande: "apt-get install software-properties-common", commentaire: "" }
#         - { commande: "apt-get install python3-certbot-nginx", commentaire: "" }
#         # - { commande: "add-apt-repository ppa:certbot/certbot", commentaire: "" }
#         # - { commande: "apt-get update", commentaire: "" }
#       loop_control:
#         label: "  -  Validating that {{ item.commande }} pour {{ item.commentaire }}"

#       tags:
#         - letsencrypt





- hosts: all
  become: true

  vars:
    certbot_admin_email: info@20100.net
    certbot_create_if_missing: true
    certbot_create_standalone_stop_services: []
    certbot_certs:
      - domains:
          - "{{ sub_domain }}.{{ domain_name }}.{{ tld }}"
    nginx_vhosts:
      - listen: "443 ssl http2"
        server_name: "{{ sub_domain }}.{{ domain_name }}.{{ tld }}" # "dev.nclsvncnt.net"
        # root: "/usr/share/nginx/html"
        root: "/mnt/disks/{{ instance_data_disk_name }}/nginx/html"
        index: "index.html index.htm"
        state: "present"
        template: "{{ nginx_vhost_template }}"
        filename: "certbot_test.conf"
        extra_parameters: |
          ssl_certificate     "/etc/letsencrypt/live/{{ sub_domain }}.{{ domain_name }}.{{ tld }}/fullchain.pem;"
          ssl_certificate_key "/etc/letsencrypt/live/{{ sub_domain }}.{{ domain_name }}.{{ tld }}/privkey.pem;"
          ssl_protocols       TLSv1.1 TLSv1.2;
          ssl_ciphers         HIGH:!aNULL:!MD5;
  pre_tasks:
    - name: Update apt cache.
      apt: update_cache=true cache_valid_time=600
      when: ansible_os_family == 'Debian'
      changed_when: false

    - name: Install dependencies (RedHat).
      yum: name={{ item }} state=present
      when: ansible_os_family == 'RedHat'
      with_items:
        - cronie
        - epel-release

    - name: "create the 'nginx/html' directory"
      file:
        state: directory
        dest: "/mnt/disks/{{ instance_data_disk_name }}/nginx/html"
        mode: 0755

    - name: "create the 'nginx/html' symlink"
      file:
        state: link
        src: "/mnt/disks/{{ instance_data_disk_name }}/nginx/html"
        name: "/home/{{ createur_linux_de_site }}/html"
        mode: 0755
        owner: "{{ createur_linux_de_site }}"
        group: "{{ groupe_linux_du_createur_de_site }}"
        force: 'true'

    - name: Install cron (Debian).
      apt: name=cron state=present
      when: ansible_os_family == 'Debian'

  roles:
    - geerlingguy.certbot
    # - geerlingguy.nginx
  tags:
    - certbot
    - lestencrypt



#- hosts:
#    - all
#  roles:
#    - role: coopdevs.certbot_nginx
#      tags:
#        - letsencrypt
#      vars:
#        domain_name: "{{ sub_domain }}.{{ domain_name }}.{{ tld }}"
#        letsencrypt_email: info@20100.net
#        certbot_version: latest
#        certbot_nginx_version: latest
#        #certbot_force_update: 'true'

#  # Example of job definition:
#  # .---------------- minute (0 - 59)
#  # |  .------------- hour (0 - 23)
#  # |  |  .---------- day of month (1 - 31)
#  # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
#  # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
#  # |  |  |  |  |
#  # *  *  *  *  * user-name command to be executed
#  tasks:
#    - name: Créations de crontabs
#      cron:
#        name: "{{ item.name }}"
#        weekday: "{{ item.weekday }}"
#        minute: "{{ item.minute }}"
#        hour: "{{ item.hour }}"
#        user: "{{ item.user | default('root') }}"
#        job: "{{ item.job }}"
#        state: "{{ item.state | default('present') }}"
#      loop:
#        - { name: "test", weekday: "*/2", minute: "7", hour: "8", user: root,
#            job: "echo '======  MLV ======'`date` >> /var/log/letsencrypt.cron.log" }
#        - { name: "renouvellement forcé des certificats TLS aux 2 jours", weekday: "*/2", minute: "8", hour: "8", user: root,
#            job: "/usr/bin/letsencrypt renew  --force-renewal --renew-hook '/etc/init.d/nginx reload' >> /var/log/letsencrypt.cron.log" }
#      tags:
#        - letsencrypt


- hosts:
    - all
  become: 'true'
  gather_facts: 'false'

  vars_files: # 'Include environment specific "gcp_*" variables (zone, creds json etc.) infos'
      - "{{ playbook_dir }}/inventories/{{ infra_environment }}/inventory.compute.gcp.yaml"
  tasks:
  - import_tasks: install-and-configure-logging-agent.yaml
    tags:
      - gcp
  - import_tasks: install-and-configure-monitoring-agent.yaml
    tags:
      - gcp
  - import_tasks: install-and-configure-figlet.yaml
  - import_tasks: configure-hostname.yaml
  - import_tasks: configure-motd.yaml



# {{{ infOpen.fail2ban
- hosts:
    - all
  roles:
    - role: infOpen.fail2ban
      tags:
        - fail2ban
      vars:
        fail2ban_service_name: 'fail2ban'
        fail2ban_jails: "{{ _fail2ban_jails | combine(mes_fail2ban_jails, recursive=true) }}"
        fail2ban_main_config_content: "{{ _fail2ban_main_config_content + mes_fail2ban_main_config_content }}"
        mes_fail2ban_main_config_content:
          - option: 'loglevel'
            value: 'INFO'
        fail2ban_filters:
          nginx-noscript:
            Definition:
              failregex: '^<HOST> -.*GET.*(\.asp|\.exe|\.pl|\.cgi|\.scgi)'
              ignoreregex: ''
          nginx-noproxy:
            Definition:
              failregex: '^<HOST> -.*GET http.*'
              ignoreregex: ''
        mes_fail2ban_jails:
          ssh:
            enabled: 'true'
            port: 'ssh'
            filter: 'sshd'
            logpath: '/var/log/auth.log'
            maxretry: 3
            bantime: 30m
            findtime: 5m
            ignoreip: '127.0.0.1/8  maison.vncnt.net'
          nginx-http-auth:
            enabled: 'true'
            filter: 'nginx-http-auth'
            port: 'http,https'
            logpath: '/var/log/nginx/error.log'
            ignoreip: '127.0.0.1/8  maison.vncnt.net'
          nginx-noscript: # source: https://www.digitalocean.com/community/tutorials/how-to-protect-an-nginx-server-with-fail2ban-on-ubuntu-14-04
            enabled: 'true'
            filter: 'nginx-noscript'
            port: 'http,https'
            logpath: '/var/log/nginx/access.log'
          nginx-badbots: # source: https://www.digitalocean.com/community/tutorials/how-to-protect-an-nginx-server-with-fail2ban-on-ubuntu-14-04
            enabled: 'true'
            filter: 'apache-badbots' # c'est voulu que ce soit Apache et pas nginx
            port: 'http,https'
            logpath: '/var/log/nginx/access.log'
            ignoreip: '127.0.0.1/8  maison.vncnt.net'
          nginx-noproxy: # source: https://www.digitalocean.com/community/tutorials/how-to-protect-an-nginx-server-with-fail2ban-on-ubuntu-14-04
            enabled: 'true'
            filter: 'nginx-noproxy'
            port: 'http,https'
            logpath: '/var/log/nginx/access.log'
            ignoreip: '127.0.0.1/8  maison.vncnt.net'
  # tasks:
  #   - name: "Configurations diverses"
  #     ini_file:
  #       path: "{{ fail2ban_paths.files.jail_local.path }}"
  #       owner: "{{ fail2ban_paths.files.jail_local.owner | default('root') }}"
  #       group: "{{ fail2ban_paths.files.jail_local.group | default('root') }}"
  #       mode: "{{ fail2ban_paths.files.jail_local.mode | default('0644') }}"
  #       section: "{{ item.section | default('DEFAULTS') }}"
  #       option: "{{ item.option }}"
  #       value: "{{ item.value }}"
  #     notify: 'HANDLER | Restart fail2ban'
  #     loop:
  #       - { option: ignoreip, value: 127.0.0.1/8 maison.vncnt.net }
  #       - { option: maxretry, value: 3 }
  #       - { option: findtime, value: 7m }
  #       - { option: bantime,  value: 11m }
  #     tags:
  #       - dev
  #       - fail2ban

# }}}




- hosts:
    - all
  become: 'true'
  gather_facts: 'false'

  roles:
    - role: nginxinc.nginx
      tags:
        - nginx
  tasks:
    - name: "Configurations diverses: access_log=OFF pour status_check"
      blockinfile:
        path: /etc/nginx/conf.d/stub_status.conf
        marker: "# {mark} ANSIBLE MANAGED BLOCK access_log = OFF pour les appels de l'agent datadog"
        insertafter: "stub_status on;"
        content: >
          access_log off;
      tags:
        - nginx

    # - name: "Configurations diverses: ajout du mapping pour ne pas logger StackDriver/Google checks"
    #   blockinfile:
    #     path: /etc/nginx/conf.d/default.conf
    #     marker: "# {mark} ANSIBLE MANAGED BLOCK ajout du mapping pour ne pas logger StackDriver/Google check"
    #     insertafter: EOF
    #     content: >
    #       map $remote_addr $log_ip { "35.191.0.0/16" 0; "130.211.0.0/22" 0; default 1; }
    #   tags:
    #     - nginx
  vars:
    nginx_enable: 'true' # Install NGINX.
    nginx_start: 'true' # Start NGINX service.
    nginx_debug_output: 'true' # Print NGINX configuration file to terminal after executing playbook.
    # nginx_version: =19-1~bionic
    nginx_state: present # 'present', 'latest' (upgrade), 'absent'
    nginx_modules: # Install NGINX JavaScript, Perl, ModSecurity WAF (NGINX Plus only), GeoIP, Image-Filter, RTMP Media Streaming (NGINX Plus only), and/or XSLT modules.
      njs: 'false'
      perl: 'false'
      waf: 'false'
      geoip: 'true'
      image_filter: 'false'
      rtmp: 'false'
      xslt: 'false'

    nginx_status_enable: 'true' # Enable NGINX status data.
    nginx_status_location: /etc/nginx/conf.d/stub_status.conf
    nginx_status_port: 80

    nginx_http_template_enable: 'true'
    nginx_http_template:
      default:
        template_file: http/default.conf.j2
        conf_file_name: default.conf
        conf_file_location: /etc/nginx/conf.d/
        # custom_options:
        #   - 'map $remote_addr $log_ip { "35.191.0.0/16" 0; "130.211.0.0/22" 0; default 1; }'
        servers:
          https:
            listen:
              listen_localhost:
                # ip: 0.0.0.0
                port: 443
                ssl: 'true'
            server_name: localhost
            # error_page: "/mnt/disks/{{ instance_purpose_name }}-data-disk-{{ random_number }}/nginx/html"
            error_page: "/mnt/disks/{{ instance_data_disk_name }}/nginx/html"
            # access_log: '/var/log/nginx/access.log main if=$log_ip;'
            autoindex: 'false'
            custom_options:
              - 'gzip on'
              - 'gzip_types text/plain application/xml'
              - 'gzip_proxied no-cache no-store private expired auth'
              # - 'gzip_min_length 1000'
              # - 'access_log /var/log/nginx/access.log main if=$log_ip'
            autoindex: 'false'
            add_headers:
              strict_transport_security:
                name: Strict-Transport-Security
                value: max-age=15768000; includeSubDomains
                always: 'true'
            ssl:
              cert: "/etc/letsencrypt/live/{{ sub_domain }}.{{ domain_name }}.{{ tld }}/fullchain.pem"
              key: "/etc/letsencrypt/live/{{ sub_domain }}.{{ domain_name }}.{{ tld }}/privkey.pem"
              protocols: TLSv1 TLSv1.1 TLSv1.2
              ciphers: HIGH:!aNULL:!MD5
              prefer_server_ciphers: true
              session_cache: none
              session_timeout: 5m
              disable_session_tickets: false
              trusted_cert: "/etc/letsencrypt/live/{{ sub_domain }}.{{ domain_name }}.{{ tld }}/cert.pem"
              stapling: true
              stapling_verify: true

            web_server:
              locations:
                default:
                  location: /
                  # html_file_location: "/mnt/disks/{{ instance_purpose_name }}-data-disk-{{ random_number }}/nginx/html"
                  html_file_location: "/mnt/disks/{{ instance_data_disk_name }}/nginx/html"
                  html_file_name: index.html
                  autoindex: 'false'
              http_demo_conf: 'false'
          http:
            listen:
              listen_localhost:
                # ip: 0.0.0.0
                port: 80
            server_name: _
            https_redirect: '$host'
            # access_log: '/var/log/nginx/access.log main if=$log_ip;'
            # custom_options:
            #   - 'access_log /var/log/nginx/access.log main if=$log_ip'



# pour activer une fois installé: possible qu'il faille faire:
# sudo service datadog-agent-sysprobe start
# sudo service enable datadog-agent-sysprobe
# sudo systemctl enable datadog-agent-sysprobe
# source: https://docs.datadoghq.com/network_performance_monitoring/installation/?tab=agent
- hosts:
    - all
  become: 'true'
  gather_facts: 'false'

  roles:
    - role: datadog.datadog
      tags:
        - datadog

  vars:
    datadog_api_key: "{{ datadog_api_key_perso }}"
    datadog_config:
      process_config:
        enabled: "true" # has to be set as a string
        scrub_args: 'true'
    system_probe_config:
      enabled: 'true'
      sysprobe_socket: /opt/datadog-agent/run/sysprobe.sock
    datadog_checks:
      process:
        init_config:
        instances:
          - name: ssh
            search_string: ['ssh', 'sshd' ]
          - name: syslog
            search_string: ['rsyslog' ]
            cpu_check_interval: 0.2
            exact_match: 'true'
            ignore_denied_access: 'true'
      ssh_check:
        init_config:
        instances:
          - host: localhost
            port: 22
            username: root
            password: changeme
            sftp_check: 'true'
            private_key_file:
            add_missing_keys: 'true'
      nginx:
         init_config:
         instances:
           - nginx_status_url: http://127.0.0.1/nginx_status/
         logs:
           - type: file
             path: /var/log/gninx/access.log
             service: myapp
             source: nginx
             sourcecategory: http_web_access
           - type: file
             path: /var/log/nginx/error.log
             service: nginx
             source: nginx
             sourcecategory: http_web_access
